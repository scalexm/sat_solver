/*
 *  expr/detail/parser.ypp
 *  solver
 *
 *  Created by Alexandre Martin on 03/02/2016.
 *  Copyright Â© 2016 scalexm. All rights reserved.
 *
 */

%skeleton "lalr1.cc"
%require "3.0.2"
%defines
%define api.namespace { expr::detail }
%define parser_class_name { parser }

%define api.token.constructor
%define api.value.type variant

%code requires {
    namespace expr { namespace detail {
        class driver;
    } }
}

%param { expr::detail::driver & driver }
%locations
%define parse.error verbose

%{
#include "driver.hpp"
%}

%define api.token.prefix {TOK_}
%token
    END 0 "end of file"
    NOT "~"
    AND "/\\"
    OR "\\/"
    XOR "X"
    IMPL "=>"
    EQUIV "<=>"
    EQ "="
    NEQ "!="
    LPAREN "("
    RPAREN ")"
    ERROR "error"
    NEW_LINE "new line"
;

%token <int> VARIABLE "variable"
%type <expr::detail::generic_expr> exp

// define left associativity AND priority (ordering is important)
%left NEW_LINE
%left EQUIV
%left IMPL
%left OR XOR
%left AND
%left NOT
%left EQ
%left NEQ

%%
%start unit;
unit: exp { driver.set_root(std::move($1)); }; // give back the result to the driver

exp:
  ERROR { YYABORT; } // used when an invalid character is encountered
| VARIABLE { $$ = expr::detail::generic_atom { std::move($1) }; }
| VARIABLE EQ VARIABLE { $$ = expr::detail::generic_atom { expr::atom::equality { $1, $3 } }; }
| VARIABLE NEQ VARIABLE {
    $$ = expr::detail::not_<generic_atom> { expr::atom::equality { $1, $3 } };
}
| LPAREN exp RPAREN { $$ = std::move($2); }
| exp AND exp { $$ = expr::detail::and_<generic_atom> { std::move($1), std::move($3) }; }
| exp NEW_LINE exp { $$ = expr::detail::and_<generic_atom> { std::move($1), std::move($3) }; }
| exp OR exp { $$ = expr::detail::or_<generic_atom> { std::move($1), std::move($3) }; }
| exp XOR exp { $$ = expr::detail::xor_<generic_atom> { std::move($1), std::move($3) }; }
| exp IMPL exp { $$ = expr::detail::impl_<generic_atom> { std::move($1), std::move($3) }; }
| exp EQUIV exp { $$ = expr::detail::equiv_<generic_atom> { std::move($1), std::move($3) }; }
| NOT exp { $$ = expr::detail::not_<generic_atom> { std::move($2) }; }
%%

/*
    report errors to the driver
*/
void expr::detail::parser::error(const location_type & l, const std::string & m) {
    driver.error(l, m);
}